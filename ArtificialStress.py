# This class implements the Artificial Stress used to avoid Tensile Instability and is based on the formulation
#  presented in the paper by Gray et al. (2001) apud Bui et al. (2008).

__author__ = 'alomir'

import numpy as np
import KernelCalc

class ArtificialStress:

    def __init__(self):
        pass

    #===================================================================================================================
    # This method calculates and returns the artificial stress tensor to be added to the momentum equation.
    def artificialStress(self, r_ij, rij, rho, tau, Ft, A, d, dp, h, nxn, numParts, simDim, IPN, kernel):

        # Fine tuning parameters for the artificial stress (usually not necessary!).
        tol = 1e-12      # Tolerance to avoid float computation errors.
        j = 1.0     # Interaction range factor.

        # Kernel local.
        Wl = np.zeros((IPN + 1,1))
        dW = np.zeros((IPN + 1,3))

        # Call kernel calculation.
        if (kernel == 'S'):
            kernelObject = KernelCalc.Spline()
        elif (kernel == 'W'):
            kernelObject = KernelCalc.Wendland()
        elif (kernel == 'QS'):
            kernelObject = KernelCalc.QuinticSpline()
        else:
            kernelObject = KernelCalc.Wendland()

        kernelObject.kernel_calcs(r_ij, rij, h, simDim, Wl, dW)

        # Reference kernel values at r = 0 and r = 1 (r = dp / h).
        Wref = np.zeros((2,1))
        kernelObject.calc_ref_kernel(Wref, dp, h, simDim)

        # Factor to be calibrated according to the simulation. Gray et al. (2001) suggest 0.3 as reference value.
        e = 0.3

        # Exponent of the force factor.
        n = np.around((Wref[0,0] / Wref[1,0]),2)
        if(n > 4): n = 4    # Limit to the repulsive force generated by the artificial stress

        # Defining the pairs of particles that are too close to each other.
        far = np.where(rij >= j * dp - tol)[0]

        # Principal artificial stresses for each particle.
        R = tau / np.power(rho, 2)
        R[R < 0] = 0
        R *= -e

        # Artificial stress tensor in the current description (similar to the Cauchy stress tensor).
        a = np.sum(np.reshape(R,(numParts + 1,3,1,1)) * nxn,1)

        # Artificial stress tensor in double point description (similar to the first Piola stress tensor).
        A[:] = np.matmul(a,np.linalg.inv(Ft))

        # Repulsive force scaling factor.
        d[:] = Wl[:] / Wref[1,0]
        d[far] = 0
        d[:] = np.power(d[:],n)

#=======================================================================================================================